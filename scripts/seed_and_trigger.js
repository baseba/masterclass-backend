// Seed DB with a confirmed remote slot for tomorrow and trigger cron endpoint
require('dotenv').config();
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();
const { execSync } = require('child_process');

async function main() {
  const TEST_EMAIL = process.env.TEST_RECEIVE_EMAIL;
  if (!TEST_EMAIL) {
    console.error('TEST_RECEIVE_EMAIL not set in .env');
    process.exit(1);
  }

  // create a professor
  const prof = await prisma.professor.create({
    data: {
      name: 'Cron Tester',
      email: `cron-tester-${Date.now()}@example.com`,
      passwordHash: 'x',
      rut: `rut-${Date.now()}`,
    },
  });

  // create a course
  const course = await prisma.course.create({
    data: {
      title: 'Cron Test Course',
      description: 'Auto-generated by seed script',
    },
  });

  // create a class
  const cls = await prisma.class.create({
    data: {
      courseId: course.id,
      title: 'Tomorrow confirmed class',
      description: 'This class is created to test cron emails',
      orderIndex: 1,
      basePrice: 0,
    },
  });

  // compute tomorrow 10:00 local
  const now = new Date();
  const tomorrow = new Date(now);
  tomorrow.setDate(now.getDate() + 1);
  tomorrow.setHours(10, 0, 0, 0);
  const end = new Date(tomorrow);
  end.setHours(tomorrow.getHours() + 1);

  // create slot
  const slot = await prisma.slot.create({
    data: {
      classId: cls.id,
      professorId: prof.id,
      startTime: tomorrow,
      endTime: end,
      modality: 'remote',
      studentsGroup: 'group',
      maxStudents: 10,
      status: 'confirmed',
    },
  });

  // create two test students that both deliver to the same inbox via plus-addressing
  // e.g. sebesfa+1@gmail.com and sebesfa+2@gmail.com will land in sebesfa@gmail.com
  const mkPlusEmail = (base, suffix) => {
    const at = base.indexOf('@');
    if (at === -1) return `${base}+${suffix}`;
    return `${base.slice(0, at)}+${suffix}${base.slice(at)}`;
  };

  const email1 = mkPlusEmail(TEST_EMAIL, '1');
  const email2 = mkPlusEmail(TEST_EMAIL, '2');

  const student1 = await prisma.student.upsert({
    where: { email: email1 },
    update: {},
    create: {
      name: 'Test Receiver 1',
      email: email1,
      passwordHash: 'x',
      rut: `rut-student-1-${Date.now()}`,
    },
  });

  const student2 = await prisma.student.upsert({
    where: { email: email2 },
    update: {},
    create: {
      name: 'Test Receiver 2',
      email: email2,
      passwordHash: 'x',
      rut: `rut-student-2-${Date.now()}`,
    },
  });

  // create two reservations (one per student) for the same slot
  const reservation1 = await prisma.reservation.create({
    data: { studentId: student1.id, slotId: slot.id, status: 'confirmed' },
  });
  const reservation2 = await prisma.reservation.create({
    data: { studentId: student2.id, slotId: slot.id, status: 'confirmed' },
  });

  console.log(
    'Seeded slot id:',
    slot.id,
    'reservation ids:',
    reservation1.id,
    reservation2.id,
    'emails:',
    email1,
    email2
  );

  // Trigger cron endpoint twice (should send one email per student, only on first run)
  const CRON_KEY = process.env.CRON_KEY;
  if (!CRON_KEY) {
    console.error('CRON_KEY not set');
    process.exit(1);
  }

  const url = `http://localhost:${
    process.env.PORT || 3000
  }/cron/daily-job?key=${CRON_KEY}`;
  console.log('Triggering', url, 'twice (1s apart)');

  try {
    const out1 = execSync(
      `curl -s -X POST "${url}" -w "\nHTTP_STATUS:%{http_code}\n"`,
      { timeout: 30000 }
    );
    console.log('First trigger response:\n', out1.toString());
  } catch (err) {
    console.error('First trigger failed', err && err.message);
  }

  // small delay
  await new Promise((r) => setTimeout(r, 1000));

  try {
    const out2 = execSync(
      `curl -s -X POST "${url}" -w "\nHTTP_STATUS:%{http_code}\n"`,
      { timeout: 30000 }
    );
    console.log('Second trigger response:\n', out2.toString());
  } catch (err) {
    console.error('Second trigger failed', err && err.message);
  }

  // done
  process.exit(0);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
